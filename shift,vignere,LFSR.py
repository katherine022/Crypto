##################################################
#Implement the following three classic ciphers using Python. You should submit file_name.pdf and file_name.py file in which file_name.pdf contains the souce code and the running results of implemented ciphers,  and the file_name.py is the souce code of your implementation.

#1) Shift Cipher
#- shift_encrypt(key, msg): It takes a key and a message (example 'abc') and outputs a ciphertext (example 'def').
#- shift_decrypt(key, ctx): It takes a key and a ciphertext and outputs a plaintext.

def shift_encrypt(key,msg) :
    enc = []
    for symbol in msg :
        if symbol.isalpha():
            num = ord(symbol)
            num += key

            if symbol.isupper() :
                if num > ord('Z') :
                    num -= 26
                elif num < ord('A') :
                    num += 26
            elif symbol.islower() :
                if num > ord('z') :
                    num -= 26
                elif num < ord('a') :
                    num += 26
            enc.append(chr(num))
        else :
            enc.append(symbol)
        
    return "".join(enc)

def shift_decrypt(key,ctx) :
    dec = []
    for symbol in ctx :
         if symbol.isalpha():
            num = ord(symbol)
            num -= key

            if symbol.isupper() :
                if num > ord('Z') :
                    num -= 26
                elif num < ord('A') :
                    num += 26
            elif symbol.islower() :
                if num > ord('z') :
                    num -= 26
                elif num < ord('a') :
                    num += 26
            dec.append(chr(num))
         else :
            dec.append(symbol)
    return "".join(dec)


#2) Vigenere Cipher
#- vigenere_genkey(n): It takes the length of key and outputs a key.
#- vigenere_encrypt(key, msg): It takes the key generated by vigenere_genkey and a plaintext, and then it outputs a ciphertext.
#- vigenere_decrypt(key, ctx): It takes the key generated by vigenere_genkey and a ciphertext, and then it outputs a plaintext.

alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
            'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
            'Y', 'Z','a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
            'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
            'w', 'x', 'y', 'z']

eng= 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'

def vigenere_genkey(n) :
    import random

    key = ""
 
    for i in range(0,n) :
        k = random.choice(alphabet)
        key += k

    return key

def vigenere_encrypt(key,msg) :
    import pyperclip
    enc = []

    keyIndex = 0

    for symbol in msg :
        num = eng.find(symbol)
        num += eng.find(key[keyIndex])

        num %= 26

        if symbol.isupper() :
            enc.append(eng[num])
        elif symbol.islower() :
            enc.append(eng[num].lower())

        keyIndex += 1
        if keyIndex == len(key) :
            keyIndex = 0
    return ''.join(enc)
        
def vigenere_decrypt(key,ctx) :
    import pyperclip
    dec = []

    keyIndex = 0

    for symbol in ctx :
        num = eng.find(symbol)
        num -= eng.find(key[keyIndex])

        num %= 26

        if symbol.isupper() :
            dec.append(eng[num])
        elif symbol.islower() :
            dec.append(eng[num].lower())

        keyIndex += 1
        if keyIndex == len(key) :
            keyIndex = 0
    return ''.join(dec)    


#3) LFSR Cipher
#- lfsr_genkey(n): It takes the length of lfsr and outputs a key that contains constants {c_i} and initial values {x_i}.
#- lfsr_encrypt(key, msg): It takes the key generated by lfsr_genkey and a plaintext, and then it outputs a ciphertext.
#- lfsr_decrypt(key, ctx): It takes the key and a plaintext, and then it outputs a ciphertext.

#When implementing LFSR Cipher, you should use mod 26 instead of mod 2. You also use addition (+) and subtraction (-) instead of XOR.

def lfsr_genkey(n) :
    import random
    c_i = []
    x_i = [random.randrange(0,26)]

    for i in range(n) :
        c_i.append(random.randrange(0,26))

    for i in range(1,n) :
        num = 0
        for j in range(i) :
            num += x_i[j]
        num += c_i[i-1]*x_i[i-1]

        num %= 26
        x_i.append(num)

    return x_i
        

def lfsr_encrypt(key,msg) :
    import pyperclip
    enc = []

    for i in range (0,len(msg)) :
        num = eng.find(msg[i])
        num += key[i]

        num %= 26

        if msg[i].isupper() :
            enc.append(eng[num])
        else :
            enc.append(eng[num].lower())
    return ''.join(enc)    

def lfsr_decrypt(key, ctx) :
    import pyperclip
    dec = []
    
    for i in range(0,len(ctx)) :
        num = eng.find(ctx[i])
        num -= key[i]

        num %= 26

        if ctx[i].isupper() :
            dec.append(eng[num])
        else :
            dec.append(eng[num].lower())
    return ''.join(dec)
